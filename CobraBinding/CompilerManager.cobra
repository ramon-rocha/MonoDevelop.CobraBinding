use Cobra.Compiler

namespace MonoDevelop.CobraBinding

class CompilerManager
	"""
	This class provides serial access to the Cobra compiler. If multiple
	threads attempt to invoke conflicting methods, the thread will be
	blocked until the compiler is available.  This class utilizes a single
	lock to avoid deadlocks for conflicting resources.
	"""
	test
		cm1 = CompilerManager.instance
		cm2 = CompilerManager.instance
		assert cm1 is cm2
	
	shared
		var _instance as CompilerManager? = nil
	
		get instance as CompilerManager
			if _instance == nil
				_instance = CompilerManager()
			return _instance to !
			
		# only the thread holding the conch can use the compiler
		var _theConch = Object()

	# Callers have to use CompilerManager.instance instead
	cue init is protected
		base.init
	
	
	def __createCompiler as Compiler
		"""
		Returns a fresh instance of the compiler.
		
		Should only be called if we have _theConch.
		"""
		compiler = Compiler(0) # verbosity = 0
		
		options = OptionValues()
		options.add("compile", true)
		options.add("back-end", "clr")
		options.add("turbo", true)
		options.add("number", "decimal")
		
		compiler.options = options
		compiler.initBackEnd
		
		# Set some shared information which gets reset everytime we instantiate a compiler.
		Node.setCompiler(compiler)
		Node.typeProvider = compiler
		
		return compiler
		
		
	def __createParser(c as Compiler) as CobraParser
		"""
		Returns a fresh instance of the Cobra parser.
		"""
		parser = CobraParser()
		parser.typeProvider = c
		parser.warningRecorder = c
		parser.errorRecorder = c
		parser.globalNS = c.globalNS
		parser.backEnd = c.backEnd
		
		return parser
	
	
	def parseAndBind(sourceMap as Dictionary<of String, String>, refs as List<of String>,
					fileToBind as String) as List<of dynamic>
		"""
		Simulates the various phases of the Cobra compiler.
		
		The phases are not instantiated directly as there is no way to provide
		raw source code to the compiler as Strings.
		
		The sourceMap is a dictionary whose values are source file contents keyed
		by filename.
		
		Returns a mixed list of Cobra modules and SourceExceptions.
		It's up to the caller to determine the type of objects in the list.
		
		TODO: Split out the psuedo-phases into functions
		"""
		
		test validFiles
			# Valid files produce fully bound ASTs without any errors.
			
			refs = List<of String>()
			cm = CompilerManager.instance
			testData = __readTestData("no_errors")
			astCount = 0

			for filePath, code in testData
				# process each file individually
				sourceMap = Dictionary<of String, String>()
				sourceMap[filePath] = code
				results = cm.parseAndBind(sourceMap, refs, filePath)
				assert results.count > 0

				for r in results
					assert not r inherits SourceException
					assert r inherits Module

					if r inherits CobraModule
						# validate the AST
						astCount += 1
						ast as CobraModule = r
						assert ast.didBindImp

						name =  FileInfo(filePath).name
						branch name
							on "Point.cobra"
								pointClass = ast.topNameSpace.memberForName("Point") to Class
								assert pointClass.memberForName("toString")
								assert pointClass.memberForName("getHashCode")
								assert pointClass.name == "Point"
								assert pointClass.typeForReceiver is pointClass
								assert pointClass.testMethods.count == 1
								p = pointClass.memberForName("x")
								assert p.getType == Property
								assert p.typeForReceiver inherits IntType
								m = pointClass.memberForName("movedBy")
								assert m.getType == Method
								assert m.typeForReceiver is pointClass

							on "Shapes.cobra"
								assert ast.topNameSpace.memberForName("Shape")
								assert ast.topNameSpace.memberForName("Rectangle")
								assert ast.topNameSpace.memberForName("Circle")
								assert ast.topNameSpace.memberForName("Program")

							on "FractalBenchmark.cobra"
								prog = ast.topNameSpace.memberForName("Program") to Class
								assert prog.memberForName("bailOut")
								assert prog.memberForName("maxIterations")
								assert prog.memberForName("mandelbrot")
								assert prog.memberForName("calc")
								assert prog.memberForName("main")

							else
								# unhandled file, a case should be added for it
								print "******* You need to add a test case for [name]!"
								assert false

			assert testData.count == astCount
				
		test parseErrors
			# Files with parse errors do not provide an AST.
			
			refs = List<of String>()
			cm = CompilerManager.instance
			testData = __readTestData("parser_errors")
			errorCount = 0

			for filePath, code in testData
				# process each file individually
				sourceMap = Dictionary<of String, String>()
				sourceMap[filePath] = code
				results = cm.parseAndBind(sourceMap, refs, filePath)
				assert results.count > 0

				for r in results
					if r inherits Module, continue # ignore modules for libraries
					
					assert r inherits ParserException

					ex as ParserException = r
					errorCount += 1
					
					name =  FileInfo(filePath).name
					branch name
						on "ExpectingEol.cobra"
							assert ex.lineNum == 3
							assert ex.colNum == 1
							assert ex.message == 'Expecting EOL, but got "var" instead.'

						on "ExpectingExpression.cobra"
							assert ex.lineNum == 5
							assert ex.colNum == 12
							assert ex.message == "Expecting an expression."

						on "ExpectingIndent.cobra"
							assert ex.lineNum == 3
							assert ex.colNum == 15
							assert ex.message == 'Expecting INDENT, but got "DEDENT" instead.'
							
						on "MissingMethodBody.cobra"
							assert ex.lineNum == 2
							assert ex.colNum == 16
							assert ex.message == 'Missing method body for "someMethod".'
							
						on "UnexpectedIndent.cobra"
							assert ex.lineNum == 2
							assert ex.colNum == 1
							assert ex.message == 'Unexpected indent.'

						else
							# unhandled file, a case should be added for it
							print "******* You need to add a test case for [name]!"
							assert false

			assert testData.count == errorCount

		test bindErrors
			# Files with binding errors still provide an AST.
			
			refs = List<of String>()
			cm = CompilerManager.instance
			testData = __readTestData("binding_errors")
			astCount = 0
			errorCount = 0

			for filePath, code in testData
				# process each file individually
				sourceMap = Dictionary<of String, String>()
				sourceMap[filePath] = code
				results = cm.parseAndBind(sourceMap, refs, filePath)
				assert results.count > 0

				for r in results
					if r inherits CobraModule or r inherits SourceException
					
						name = FileInfo(r.fileName).name
					
						if r inherits SourceException
							errorCount += 1
							
							branch name
								on "CannotFindType.cobra"
									assert r.lineNum == 3
									assert r.colNum > 0 # binding errors don't provide a column number
									assert r.message == 'Cannot find "Fake".'
									
								on "NilError.cobra"
									assert r.lineNum == 5
									assert r.colNum > 0
									assert r.message == 'Cannot return String? because "method" is declared to return a String.'
									
								on "TypeMismatch.cobra"
									assert r.lineNum == 4
									assert r.colNum > 0
									assert r.message == 'Incompatible types. Cannot assign value of type int on the right to String on the left.'
									
								else
									# unhandled file, a case should be added for it
									print "******* You need to add a test case for [name]!"
									assert false
						
						else if r inherits CobraModule
							astCount += 1
							
							branch name
								on "CannotFindType.cobra"
									c = r.topNameSpace.memberForName("CannotFindType") to Class
									assert c.memberForName("method")
									
								on "NilError.cobra"
									c = r.topNameSpace.memberForName("NilError") to Class
									assert c.memberForName("a")
									assert c.memberForName("method")
									
								on "TypeMismatch.cobra"
									c = r.topNameSpace.memberForName("TypeMismatch") to Class
									assert c.memberForName("method")
									
								else
									# unhandled file, a case should be added for it
									print "******* You need to add a test case for [name]!"
									assert false
					
			assert testData.count == astCount
			# TODO: assert astCount == errorCount
			# Well how do you like that?  I've been missing binding errors this whole time...+1 for tests...

		body
			results = List<of dynamic>()
			
			if sourceMap.count == 0
				# nothing to do
				return results
			
			lock _theConch
				compiler = __createCompiler
				compiler.options['reference'] = refs
				
				# BindRunTimeLibraryPhase
				compiler.addRunTimeRef(compiler.options)
				
				# ReadLibrariesPhase
				compiler.readSystemTypes
				compiler.readAssemblyTypes(compiler.options)
				
				# ParsePhase
				parser = __createParser(compiler)
				
				# parse the source files to generate our preliminary AST
				for fileName, sourceCode in sourceMap
					try
						m = parser.parseSource(fileName, sourceCode)
						compiler.modules.add(m)
						
					catch ex as SourceException
						results.add(ex)
				
				if compiler.errors.count == 0
					# BindUsePhase
					i = 0
					while i < compiler.modules.count  # new modules can be added, say by the UseDirective
						compiler.curModule = compiler.modules[i]
						try
							compiler.curModule.bindUse
						catch ex as SourceException
							results.add(ex)
							compiler.recordError(ex)
						i += 1
				
				if compiler.errors.count == 0
					# BindInheritancePhase
					for basicType in compiler.basicTypes
						basicType.bindInh
						compiler.objectType.bindInh
						compiler.stringType.bindInh
						compiler.dynamicType.bindInh
						compiler.passThroughType.bindInh
						compiler.voidType.bindInh
						for mod in compiler.modules.clone
							if mod.fileName == fileToBind
								compiler.curModule = mod
								try
									mod.bindInh
								catch ex as SourceException
									results.add(ex)
									compiler.recordError(ex)

				if compiler.errors.count == 0
					# BindInterfacePhase
					compiler.fixMemberSigs
					for basicType in compiler.basicTypes
						basicType.bindInt
					compiler.objectType.bindInt
					compiler.stringType.bindInt
					compiler.dynamicType.bindInt
					compiler.passThroughType.bindInt
					compiler.voidType.bindInt
					for mod in compiler.modules.clone
						compiler.curModule = mod
						try
							mod.bindInt
						catch ex as SourceException
							results.add(ex)
							compiler.recordError(ex)
				
				if compiler.errors.count == 0
					# ComputeMatchingBaseMembersPhase
					for mod in compiler.modules
						compiler.curModule = mod
						try
							mod.computeMatchingBaseMembers
						catch ex as SourceException
							results.add(ex)
							compiler.recordError(ex)
				
				if compiler.errors.count == 0
					# BindImplementationPhase
					for mod in compiler.modules.clone
						if mod.fileName == fileToBind
							compiler.curModule = mod
							try
								mod.bindImp
							catch ex as SourceException
								results.add(ex)
								compiler.recordError(ex)
							catch
								print "[fileToBind] triggers a compiler bug"

				for module in compiler.modules
					results.add(module)
				
			return results

	def parse(fileName as String, source as String) as dynamic
		"""
		Invokes the Cobra parser on the given source code and returns
		the resulting CobraModule.  If a parser error occurs, this
		method returns a ParserException.  It's up to the caller
		to determine the type of the returned object.
		"""
		test successfulParse
			cm = CompilerManager.instance
			
			fileName = "hello.cobra"
			source = "class Hello\n\tdef main\n\t\tprint 'Hello, World!'\n"
			
			module = cm.parse(fileName, source)
			
			assert module inherits CobraModule
			d = module.topNameSpace.declsInOrder[0]
			assert d inherits Class
			assert d.idToken.text == "Hello"
		test parserError
			cm = CompilerManager.instance
			
			fileName = "error.cobra"
			source = "class Hello\n\tdef main\n"
			
			err = cm.parse(fileName, source)
			
			assert err inherits ParserException
			assert err.lineNum == 2
			assert err.colNum == 10
			assert err.message == 'Missing method body for "main".'
		body
			lock _theConch
				compiler = __createCompiler
				parser = __createParser(compiler)
				try
					return parser.parseSource(fileName, source)
				catch ex as ParserException
					return ex


	shared
		def __readTestData(folder as String) as Dictionary<of String, String>
			"""
			This function is only for supporting test methods.  The 'folder'
			parameter should exist under '../../test_data' which is relative
			to the location of the 'scripts/refs' path under 'CobraBinding'.
			"""
			s = Path.directorySeparatorChar
			testDir = "..[s]..[s]test_data[s][folder]"
			assert Directory.exists(testDir)

			sourceMap = Dictionary<of String, String>()

			files = Directory.getFiles(testDir)
			for filePath in files
				reader = StreamReader(filePath)
				code = reader.readToEnd ? ""

				sourceMap[filePath] = code

			return sourceMap
